--
-- PostgreSQL database dump
--

-- Dumped from database version 15.0
-- Dumped by pg_dump version 15.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: dead_addrs(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.dead_addrs() RETURNS TABLE(dead1 text, dead2 text)
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT ('0x000000000000000000000000000000000000dead', '0x0000000000000000000000000000000000000000')
$$;


ALTER FUNCTION public.dead_addrs() OWNER TO postgres;

--
-- Name: key_exists(json, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.key_exists(some_json json, outer_key text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (some_json->outer_key) IS NOT NULL;
END;
$$;


ALTER FUNCTION public.key_exists(some_json json, outer_key text) OWNER TO postgres;

--
-- Name: minting_labels(text, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.minting_labels(user_address text, minutes numeric) RETURNS TABLE(address text, collection json, deployed_ago timestamp without time zone, mints bigint, mints_change numeric, minters bigint, minters_change numeric, volume numeric, volume_change numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
		WITH wallets AS (
			SELECT l1.address as to_address FROM labels l1 WHERE l1.user = user_address AND l1.type = 0
			UNION ALL
			SELECT t.to_address FROM tokens t WHERE t.address IN (SELECT l2.address FROM labels l2 WHERE l2.user = user_address AND l2.type = 1)
		)
		, prior_frame AS (
		    SELECT m1.address, COUNT(price_as_eth) as mints, COUNT(DISTINCT (to_address)) as minters, SUM(price_as_eth) as volume FROM mints m1 
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND block_timestamp < '2022-06-17 17:48:24.74218+02'::TIMESTAMP - (minutes * 2) *INTERVAL '1 MINUTES' 
		    AND to_address IN (SELECT w.to_address FROM wallets w)
		    GROUP BY m1.address)
		, frame AS (
		    SELECT m2.address, COUNT(price_as_eth) as mints, COUNT(DISTINCT (to_address)) as minters, SUM(price_as_eth) as volume FROM mints m2
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND to_address IN (SELECT w.to_address FROM wallets w)
		    GROUP BY m2.address)
		SELECT 
		f.address,
		json_build_object(
		'address', f.address,
		'name', c.name,
		'image_url', c.metadata->>'image_url'
		) as collection,
		c.block_timestamp as deployed_ago,
		f.mints,
		percentage_change(pf.mints, f.mints) as mints_change,
		f.minters,
		percentage_change(pf.minters, f.minters) as minters_change,
		wei_to_eth(f.volume) as volume,
		percentage_change(pf.volume, f.volume) as volume_change
		FROM frame f 
		LEFT JOIN prior_frame pf ON f.address = pf.address
		LEFT JOIN contracts c ON f.address = c.address
		WHERE c.name IS NOT NULL
		ORDER BY volume DESC
		LIMIT 50;
END; $$;


ALTER FUNCTION public.minting_labels(user_address text, minutes numeric) OWNER TO postgres;

--
-- Name: percentage_change(numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.percentage_change(numeric, numeric) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT ((($2 / NULLIF($1,0)) * 100) - 100)::NUMERIC(78,2)
$_$;


ALTER FUNCTION public.percentage_change(numeric, numeric) OWNER TO postgres;

--
-- Name: task_mint_decode(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.task_mint_decode(integer) RETURNS void
    LANGUAGE sql
    AS $_$
WITH transfers AS (
SELECT * FROM token_transfers WHERE block_number = $1
), internals AS (
SELECT * FROM filtered_internals WHERE block_number = $1
)
INSERT INTO mints
SELECT t.address, t.block_number, t.block_timestamp, t.block_hash, t.transaction_hash, t.transaction_index, t.log_index, t.from_address, t.to_address, t.token_id, '0x0000000000000000000000000000000000000000' as currency,
(((SELECT SUM (value::NUMERIC(78,0)) FROM filtered_internals i WHERE i.transaction_hash = t.transaction_hash AND i.to_address = t.address AND i.from_address = t.to_address AND i.status = 1)) / (count(*) OVER (PARTITION BY t.transaction_hash)))::NUMERIC(78,0) as price,
(((SELECT SUM (value::NUMERIC(78,0)) FROM filtered_internals i WHERE i.transaction_hash = t.transaction_hash AND i.to_address = t.address AND i.from_address = t.to_address AND i.status = 1)) / (count(*) OVER (PARTITION BY t.transaction_hash)))::NUMERIC(78,0) as price_as_eth
FROM transfers t 
WHERE t.from_address = '0x0000000000000000000000000000000000000000' 
AND EXISTS (SELECT from_address FROM internals fi WHERE fi.transaction_hash = t.transaction_hash AND fi.from_address = t.to_address AND fi.to_address = t.address)
$_$;


ALTER FUNCTION public.task_mint_decode(integer) OWNER TO postgres;

--
-- Name: to_utc(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.to_utc(timestamp with time zone) RETURNS timestamp without time zone
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT $1 at time zone 'utc'
$_$;


ALTER FUNCTION public.to_utc(timestamp with time zone) OWNER TO postgres;

--
-- Name: trending(numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trending(minutes numeric) RETURNS TABLE(address text, collection json, deployed_ago timestamp without time zone, floor numeric, floor_change numeric, floor_old numeric, sales bigint, sales_change numeric, sales_old bigint, average numeric, average_change numeric, average_old numeric, volume numeric, volume_change numeric, volume_old numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
		WITH prior_frame AS (
		    SELECT s1.address, MIN(price_as_eth) as floor, COUNT(price_as_eth) as sales, AVG(price_as_eth) as average, SUM(price_as_eth) as volume FROM sales s1 
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND block_timestamp < '2022-06-17 17:48:24.74218+02'::TIMESTAMP - (minutes * 2) *INTERVAL '1 MINUTES' 
		    AND price_as_eth IS NOT NULL AND price_as_eth > 0
		    GROUP BY s1.address)
		, frame AS (
		    SELECT s2.address, MIN(price_as_eth) as floor, COUNT(price_as_eth) as sales, AVG(price_as_eth) as average, SUM(price_as_eth) as volume FROM sales s2 
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND price_as_eth IS NOT NULL AND price_as_eth > 0
		    GROUP BY s2.address)
		SELECT
		f.address,
		json_build_object(
		'address', f.address,
		'name', c.name,
		'image_url', c.metadata->>'image_url'
		) as collection,
		c.block_timestamp as deployed_ago,
		wei_to_eth(f.floor) as floor,
		percentage_change(pf.floor, f.floor) as floor_change,
		wei_to_eth(pf.floor) as floor_old,
		f.sales,
		percentage_change(pf.sales,f.sales) as sales_change,
		pf.sales as sales_old,
		wei_to_eth(f.average) as average,
		percentage_change(pf.average, f.average) as average_change,
		wei_to_eth(pf.average) as average_old,
		wei_to_eth(f.volume) as volume,
		percentage_change(pf.volume, f.volume) as volume_change,
		wei_to_eth(pf.volume) as volume_old
		FROM frame f 
		LEFT JOIN prior_frame pf ON f.address = pf.address
		LEFT JOIN contracts c ON f.address = c.address
		WHERE c.name IS NOT NULL
		ORDER BY sales DESC
		LIMIT 50;
END; $$;


ALTER FUNCTION public.trending(minutes numeric) OWNER TO postgres;

--
-- Name: trending_labels(text, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trending_labels(user_address text, minutes numeric) RETURNS TABLE(address text, collection json, deployed_ago timestamp without time zone, floor numeric, floor_change numeric, floor_old numeric, sales bigint, sales_change numeric, sales_old bigint, average numeric, average_change numeric, average_old numeric, volume numeric, volume_change numeric, volume_old numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
		WITH wallets AS (
			SELECT l1.address as to_address FROM labels l1 WHERE l1.user = user_address AND l1.type = 0
			UNION ALL
			SELECT t.to_address FROM tokens t WHERE t.address IN (SELECT l2.address FROM labels l2 WHERE l2.user = user_address AND l2.type = 1)
		)
		, prior_frame AS (
		    SELECT s1.address, MIN(price_as_eth) as floor, COUNT(price_as_eth) as sales, AVG(price_as_eth) as average, SUM(price_as_eth) as volume FROM sales s1 
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND block_timestamp < '2022-06-17 17:48:24.74218+02'::TIMESTAMP - (minutes * 2) *INTERVAL '1 MINUTES' 
		    AND price_as_eth IS NOT NULL AND price_as_eth > 0
		    AND to_address IN (SELECT w.to_address FROM wallets w)
		    GROUP BY s1.address)
		, frame AS (
		    SELECT s2.address, MIN(price_as_eth) as floor, COUNT(price_as_eth) as sales, AVG(price_as_eth) as average, SUM(price_as_eth) as volume FROM sales s2 
		    WHERE block_timestamp > '2022-06-17 17:48:24.74218+02'::TIMESTAMP - minutes * INTERVAL '1 MINUTES' 
		    AND price_as_eth IS NOT NULL AND price_as_eth > 0
		   	AND to_address IN (SELECT w.to_address FROM wallets w)
		    GROUP BY s2.address)
		SELECT
		f.address,
		json_build_object(
		'address', f.address,
		'name', c.name,
		'image_url', c.metadata->>'image_url'
		) as collection,
		c.block_timestamp as deployed_ago,
		wei_to_eth(f.floor) as floor,
		percentage_change(pf.floor, f.floor) as floor_change,
		wei_to_eth(pf.floor) as floor_old,
		f.sales,
		percentage_change(pf.sales,f.sales) as sales_change,
		pf.sales as sales_old,
		wei_to_eth(f.average) as average,
		percentage_change(pf.average, f.average) as average_change,
		wei_to_eth(pf.average) as average_old,
		wei_to_eth(f.volume) as volume,
		percentage_change(pf.volume, f.volume) as volume_change,
		wei_to_eth(pf.volume) as volume_old
		FROM frame f 
		LEFT JOIN prior_frame pf ON f.address = pf.address
		LEFT JOIN contracts c ON f.address = c.address
		WHERE c.name IS NOT NULL
		ORDER BY sales DESC
		LIMIT 50;
END; $$;


ALTER FUNCTION public.trending_labels(user_address text, minutes numeric) OWNER TO postgres;

--
-- Name: wei_to_eth(numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.wei_to_eth(numeric) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT ($1 / POWER(10,18)::NUMERIC(78,4))::NUMERIC(78,4)
$_$;


ALTER FUNCTION public.wei_to_eth(numeric) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: alerts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alerts (
    id integer NOT NULL,
    name text NOT NULL,
    type_id integer NOT NULL,
    arguments jsonb DEFAULT '{}'::jsonb NOT NULL,
    delivery_channel_id integer NOT NULL,
    delivery_arguments jsonb DEFAULT '{}'::jsonb NOT NULL,
    active boolean NOT NULL,
    "user" text NOT NULL
);


ALTER TABLE public.alerts OWNER TO postgres;

--
-- Name: alerts_delivery_channels; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alerts_delivery_channels (
    id integer NOT NULL,
    name text NOT NULL,
    active boolean NOT NULL
);


ALTER TABLE public.alerts_delivery_channels OWNER TO postgres;

--
-- Name: alerts_delivery_channels_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alerts_delivery_channels_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alerts_delivery_channels_id_seq OWNER TO postgres;

--
-- Name: alerts_delivery_channels_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alerts_delivery_channels_id_seq OWNED BY public.alerts_delivery_channels.id;


--
-- Name: alerts_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alerts_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alerts_id_seq OWNER TO postgres;

--
-- Name: alerts_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alerts_id_seq OWNED BY public.alerts.id;


--
-- Name: alerts_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alerts_types (
    id integer NOT NULL,
    name text NOT NULL,
    active boolean NOT NULL,
    class integer
);


ALTER TABLE public.alerts_types OWNER TO postgres;

--
-- Name: alerts_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alerts_types_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alerts_types_id_seq OWNER TO postgres;

--
-- Name: alerts_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alerts_types_id_seq OWNED BY public.alerts_types.id;


--
-- Name: all_contracts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.all_contracts (
    address text NOT NULL,
    block_number integer,
    block_timestamp timestamp with time zone,
    block_hash text,
    name text,
    symbol text,
    version smallint,
    "is_ERC721_interface" boolean,
    "is_ERC721_etl" boolean
);


ALTER TABLE public.all_contracts OWNER TO postgres;

--
-- Name: contracts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contracts (
    address text NOT NULL,
    block_number integer NOT NULL,
    block_timestamp timestamp without time zone NOT NULL,
    block_hash text,
    name text,
    symbol text,
    metadata json,
    version smallint,
    image_url text
);


ALTER TABLE public.contracts OWNER TO postgres;

--
-- Name: contracts_clone; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contracts_clone (
    address text,
    block_number integer,
    block_timestamp timestamp without time zone,
    block_hash text,
    name text,
    symbol text,
    metadata json,
    version smallint,
    image_url text
);


ALTER TABLE public.contracts_clone OWNER TO postgres;

--
-- Name: filtered_internals; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.filtered_internals (
    transaction_hash text,
    transaction_index integer,
    from_address text,
    to_address text,
    value numeric(78,0),
    input text,
    output text,
    trace_type text,
    call_type text,
    reward_type text,
    gas bigint,
    gas_used bigint,
    subtraces bigint,
    trace_address text,
    error text,
    status smallint,
    block_timestamp timestamp with time zone,
    block_number integer,
    block_hash text,
    trace_id text NOT NULL,
    version smallint
);


ALTER TABLE public.filtered_internals OWNER TO postgres;

--
-- Name: filtered_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.filtered_logs (
    log_index integer NOT NULL,
    transaction_hash text NOT NULL,
    transaction_index integer NOT NULL,
    address text NOT NULL,
    data text NOT NULL,
    topics text[] NOT NULL,
    block_timestamp timestamp with time zone NOT NULL,
    block_number integer NOT NULL,
    block_hash text NOT NULL,
    version smallint NOT NULL
);


ALTER TABLE public.filtered_logs OWNER TO postgres;

--
-- Name: labels; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.labels (
    id integer NOT NULL,
    address text NOT NULL,
    type smallint NOT NULL,
    "user" text NOT NULL
);


ALTER TABLE public.labels OWNER TO postgres;

--
-- Name: labels_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.labels_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.labels_id_seq OWNER TO postgres;

--
-- Name: labels_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.labels_id_seq OWNED BY public.labels.id;


--
-- Name: mints; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mints (
    address text NOT NULL,
    block_number integer NOT NULL,
    block_timestamp timestamp with time zone NOT NULL,
    block_hash text NOT NULL,
    transaction_hash text NOT NULL,
    transaction_index integer NOT NULL,
    log_index integer NOT NULL,
    from_address text NOT NULL,
    to_address text NOT NULL,
    token_id text NOT NULL,
    currency text NOT NULL,
    price numeric(78,0),
    price_as_eth numeric(78,0)
);


ALTER TABLE public.mints OWNER TO postgres;

--
-- Name: sales; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sales (
    address text NOT NULL,
    block_number integer NOT NULL,
    block_timestamp timestamp without time zone NOT NULL,
    from_address text NOT NULL,
    log_index integer NOT NULL,
    marketplace smallint NOT NULL,
    price text NOT NULL,
    to_address text NOT NULL,
    token_id text NOT NULL,
    transaction_hash text NOT NULL,
    transaction_index integer NOT NULL,
    block_hash text NOT NULL,
    currency text NOT NULL,
    is_bundle boolean NOT NULL,
    sale_type smallint NOT NULL,
    sale_index integer NOT NULL,
    price_as_eth numeric(78,0)
);


ALTER TABLE public.sales OWNER TO postgres;

--
-- Name: token; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.token (
    token text NOT NULL,
    "user" text NOT NULL,
    type text NOT NULL,
    expires timestamp without time zone NOT NULL,
    blacklisted boolean NOT NULL
);


ALTER TABLE public.token OWNER TO postgres;

--
-- Name: token_transfers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.token_transfers (
    transaction_hash text NOT NULL,
    log_index integer NOT NULL,
    transaction_index integer NOT NULL,
    address text NOT NULL,
    data text NOT NULL,
    from_address text NOT NULL,
    to_address text NOT NULL,
    token_id text NOT NULL,
    block_number integer NOT NULL,
    block_hash text NOT NULL,
    block_timestamp timestamp with time zone NOT NULL,
    version smallint NOT NULL
);


ALTER TABLE public.token_transfers OWNER TO postgres;

--
-- Name: tokens; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tokens (
    transaction_hash text NOT NULL,
    log_index integer NOT NULL,
    transaction_index integer NOT NULL,
    address text NOT NULL,
    data text NOT NULL,
    from_address text NOT NULL,
    to_address text NOT NULL,
    token_id text NOT NULL,
    block_number integer NOT NULL,
    block_hash text NOT NULL,
    block_timestamp timestamp without time zone NOT NULL,
    version smallint NOT NULL
);


ALTER TABLE public.tokens OWNER TO postgres;

--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    address text NOT NULL,
    premium_finish_timestamp bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: wallets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.wallets (
    to_address text NOT NULL,
    tokens jsonb
);


ALTER TABLE public.wallets OWNER TO postgres;

--
-- Name: alerts id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts ALTER COLUMN id SET DEFAULT nextval('public.alerts_id_seq'::regclass);


--
-- Name: alerts_delivery_channels id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts_delivery_channels ALTER COLUMN id SET DEFAULT nextval('public.alerts_delivery_channels_id_seq'::regclass);


--
-- Name: alerts_types id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts_types ALTER COLUMN id SET DEFAULT nextval('public.alerts_types_id_seq'::regclass);


--
-- Name: labels id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.labels ALTER COLUMN id SET DEFAULT nextval('public.labels_id_seq'::regclass);


--
-- Name: alerts_delivery_channels alerts_delivery_channels_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts_delivery_channels
    ADD CONSTRAINT alerts_delivery_channels_pkey PRIMARY KEY (id);


--
-- Name: alerts alerts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts
    ADD CONSTRAINT alerts_pkey PRIMARY KEY (id);


--
-- Name: alerts_types alerts_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alerts_types
    ADD CONSTRAINT alerts_types_pkey PRIMARY KEY (id);


--
-- Name: contracts contracts_pkey1; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contracts
    ADD CONSTRAINT contracts_pkey1 PRIMARY KEY (address);


--
-- Name: filtered_internals filtered_internals_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.filtered_internals
    ADD CONSTRAINT filtered_internals_pkey PRIMARY KEY (trace_id);


--
-- Name: filtered_logs filtered_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.filtered_logs
    ADD CONSTRAINT filtered_logs_pkey PRIMARY KEY (block_number, log_index);


--
-- Name: labels labels_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.labels
    ADD CONSTRAINT labels_pkey PRIMARY KEY (id);


--
-- Name: mints mints2_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mints
    ADD CONSTRAINT mints2_pkey PRIMARY KEY (block_number, log_index);


--
-- Name: sales sales2_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sales
    ADD CONSTRAINT sales2_pkey PRIMARY KEY (block_number, log_index, sale_index);


--
-- Name: token token_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.token
    ADD CONSTRAINT token_pkey PRIMARY KEY (token);


--
-- Name: token_transfers token_transfers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.token_transfers
    ADD CONSTRAINT token_transfers_pkey PRIMARY KEY (block_number, log_index);


--
-- Name: tokens tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tokens
    ADD CONSTRAINT tokens_pkey PRIMARY KEY (block_number, log_index);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (address);


--
-- Name: wallets wallets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.wallets
    ADD CONSTRAINT wallets_pkey PRIMARY KEY (to_address);


--
-- Name: filtered_internals_idx_bnumber; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX filtered_internals_idx_bnumber ON public.filtered_internals USING btree (block_number);


--
-- Name: filtered_internals_idx_hash; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX filtered_internals_idx_hash ON public.filtered_internals USING btree (transaction_hash);


--
-- Name: filtered_logs_idx_tx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX filtered_logs_idx_tx ON public.filtered_logs USING btree (transaction_hash);


--
-- Name: mints2_idx_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX mints2_idx_address ON public.mints USING btree (address);


--
-- Name: mints2_idx_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX mints2_idx_time ON public.mints USING btree (block_timestamp);


--
-- Name: mints2_idx_to_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX mints2_idx_to_address ON public.mints USING btree (to_address);


--
-- Name: token_transfers_idx_address; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX token_transfers_idx_address ON public.token_transfers USING btree (address, token_id);


--
-- Name: token_transfers_idx_hash; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX token_transfers_idx_hash ON public.token_transfers USING btree (transaction_hash);


--
-- Name: tokens_address_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX tokens_address_idx ON public.tokens USING btree (address);


--
-- Name: tokens_to_address_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX tokens_to_address_idx ON public.tokens USING btree (to_address);


--
-- Name: token token_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.token
    ADD CONSTRAINT token_user_fkey FOREIGN KEY ("user") REFERENCES public.users(address) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

